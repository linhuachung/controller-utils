{"version":3,"file":"siwe.js","sourceRoot":"","sources":["../src/siwe.ts"],"names":[],"mappings":"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","sourcesContent":["import { ParsedMessage } from '@spruceid/siwe-parser';\r\nimport { isHexPrefixed } from 'ethereumjs-util';\r\n\r\nimport { projectLogger, createModuleLogger } from './logger';\r\n\r\nconst log = createModuleLogger(projectLogger, 'detect-siwe');\r\n\r\n/**\r\n * This function strips the hex prefix from a string if it has one.\r\n *\r\n * @param str - The string to check\r\n * @returns The string without the hex prefix\r\n */\r\nfunction stripHexPrefix(str: string) {\r\n  if (typeof str !== 'string') {\r\n    return str;\r\n  }\r\n  return isHexPrefixed(str) ? str.slice(2) : str;\r\n}\r\n\r\n/**\r\n * This function converts a hex string to text if it's not a 32 byte hex string.\r\n *\r\n * @param hex - The hex string to convert to text\r\n * @returns The text representation of the hex string\r\n */\r\nfunction msgHexToText(hex: string): string {\r\n  try {\r\n    const stripped = stripHexPrefix(hex);\r\n    const buff = Buffer.from(stripped, 'hex');\r\n    return buff.length === 32 ? hex : buff.toString('utf8');\r\n  } catch (e) {\r\n    log(e);\r\n    return hex;\r\n  }\r\n}\r\n\r\n/**\r\n * @type WrappedSIWERequest\r\n *\r\n * Sign-In With Ethereum (SIWE)(EIP-4361) message with request metadata\r\n * @property {string} from - Subject account address\r\n * @property {string} origin - The RFC 3986 originating authority of the signing request, including scheme\r\n * @property {ParsedMessage} siwe - The data parsed from the message\r\n */\r\nexport interface WrappedSIWERequest {\r\n  from: string;\r\n  origin: string;\r\n  siwe: SIWEMessage;\r\n}\r\n\r\ninterface DomainParts {\r\n  username?: string;\r\n  hostname: string;\r\n  port?: string;\r\n}\r\n\r\nconst DEFAULT_PORTS_BY_PROTOCOL = {\r\n  'http:': '80',\r\n  'https:': '443',\r\n} as Record<string, string>;\r\n\r\n/**\r\n * Parses parts from RFC 3986 authority from EIP-4361 `domain` field.\r\n *\r\n * @param domain - input string\r\n * @param originProtocol - implied protocol from origin\r\n * @returns parsed parts\r\n */\r\nexport const parseDomainParts = (\r\n  domain: string,\r\n  originProtocol: string,\r\n): DomainParts => {\r\n  if (domain.match(/^[^/:]*:\\/\\//u)) {\r\n    return new URL(domain);\r\n  }\r\n  return new URL(`${originProtocol}//${domain}`);\r\n};\r\n\r\n/**\r\n * Validates origin of a Sign-In With Ethereum (SIWE)(EIP-4361) request.\r\n * As per spec:\r\n * hostname must match.\r\n * port and username must match iff specified.\r\n * Protocol binding and full same-origin are currently not performed.\r\n *\r\n * @param req - Signature request\r\n * @returns true if origin matches domain; false otherwise\r\n */\r\nexport const isValidSIWEOrigin = (req: WrappedSIWERequest): boolean => {\r\n  try {\r\n    const { origin, siwe } = req;\r\n\r\n    // origin = scheme://[user[:password]@]domain[:port]\r\n    // origin is supplied by environment and must match domain claim in message\r\n    if (!origin || !siwe?.parsedMessage?.domain) {\r\n      return false;\r\n    }\r\n\r\n    const originParts = new URL(origin);\r\n    const domainParts = parseDomainParts(\r\n      siwe.parsedMessage.domain,\r\n      originParts.protocol,\r\n    );\r\n\r\n    if (\r\n      domainParts.hostname.localeCompare(originParts.hostname, undefined, {\r\n        sensitivity: 'accent',\r\n      }) !== 0\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    if (domainParts.port !== '' && domainParts.port !== originParts.port) {\r\n      // If origin port is not specified, protocol default is implied\r\n      return (\r\n        originParts.port === '' &&\r\n        domainParts.port === DEFAULT_PORTS_BY_PROTOCOL[originParts.protocol]\r\n      );\r\n    }\r\n\r\n    if (\r\n      domainParts.username !== '' &&\r\n      domainParts.username !== originParts.username\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  } catch (e) {\r\n    log(e);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * A locally defined object used to provide data to identify a Sign-In With Ethereum (SIWE)(EIP-4361) message and provide the parsed message\r\n *\r\n * @typedef SIWEMessage\r\n * @param {boolean} isSIWEMessage - Does the intercepted message conform to the SIWE specification?\r\n * @param {ParsedMessage} parsedMessage - The data parsed out of the message\r\n */\r\nexport type SIWEMessage =\r\n  | { isSIWEMessage: true; parsedMessage: ParsedMessage }\r\n  | { isSIWEMessage: false; parsedMessage: null };\r\n\r\n/**\r\n * This function intercepts a sign message, detects if it's a\r\n * Sign-In With Ethereum (SIWE)(EIP-4361) message, and returns an object with\r\n * relevant SIWE data.\r\n *\r\n * {@see {@link https://eips.ethereum.org/EIPS/eip-4361}}\r\n *\r\n * @param msgParams - The params of the message to sign\r\n * @param msgParams.data - The data of the message to sign\r\n * @returns An object with the relevant SIWE data\r\n */\r\nexport const detectSIWE = (msgParams: { data: string }): SIWEMessage => {\r\n  try {\r\n    const { data } = msgParams;\r\n    const message = msgHexToText(data);\r\n    const parsedMessage = new ParsedMessage(message);\r\n\r\n    return {\r\n      isSIWEMessage: true,\r\n      parsedMessage,\r\n    };\r\n  } catch (error) {\r\n    // ignore error, it's not a valid SIWE message\r\n    return {\r\n      isSIWEMessage: false,\r\n      parsedMessage: null,\r\n    };\r\n  }\r\n};\r\n"]}